const { SSHService } = require('./ssh');
const { logger } = require('./logger');
const chalk = require('chalk');

class MonitoringService {
  constructor() {
    this.sshService = new SSHService();
  }

  async setupHealthChecks(host, config, options = {}) {
    const { dryRun = false, sshOptions = {} } = options;
    
    if (dryRun) {
      logger.info(chalk.cyan(`[DRY RUN] Would setup health checks for ${config.projectName}`));
      return { success: true };
    }

    logger.info(chalk.blue('🏥 Setting up health checks...'));

    try {
      // Create health check script
      const healthCheckScript = this.generateHealthCheckScript(config);
      const operatingSystem = sshOptions.operatingSystem || 'ubuntu';
      const defaultUser = operatingSystem === 'debian' ? 'admin' : 'ubuntu';
      const scriptPath = `/home/${defaultUser}/${config.projectName}/health-check.sh`;
      
      await this.sshService.writeFile(host, scriptPath, healthCheckScript, sshOptions);
      await this.sshService.executeCommand(host, `chmod +x ${scriptPath}`, sshOptions);

      // Setup cron job for periodic health checks
      await this.setupHealthCheckCron(host, config, sshOptions);

      // Create health check log directory
      await this.sshService.createDirectory(host, `/var/log/${config.projectName}`, sshOptions);
      await this.sshService.executeCommand(
        host, 
        `sudo chown ubuntu:ubuntu /var/log/${config.projectName}`, 
        sshOptions
      );

      logger.success(chalk.green('✅ Health checks configured'));
      return { success: true };

    } catch (error) {
      logger.error(chalk.red(`❌ Failed to setup health checks: ${error.message}`));
      throw error;
    }
  }

  generateHealthCheckScript(config) {
    const appPort = config.app?.port || 3000;
    const healthEndpoint = config.health?.endpoint || '/health';
    const timeout = config.health?.timeout || 10;
    
    return `#!/bin/bash

# Health check script for ${config.projectName}
# Generated by focal-deploy

LOG_FILE="/var/log/${config.projectName}/health-check.log"
APP_URL="http://localhost:${appPort}${healthEndpoint}"
TIMESTAMP=$(date '+%Y-%m-%d %H:%M:%S')

# Function to log messages
log_message() {
    echo "[$TIMESTAMP] $1" >> "$LOG_FILE"
}

# Function to send alert (placeholder for future implementation)
send_alert() {
    local message="$1"
    log_message "ALERT: $message"
    # Future: Send to Slack, email, etc.
}

# Check if application is responding
check_app_health() {
    local response_code=$(curl -s -o /dev/null -w "%{http_code}" --max-time ${timeout} "$APP_URL" 2>/dev/null)
    
    if [ "$response_code" = "200" ]; then
        log_message "✅ Health check passed - HTTP $response_code"
        return 0
    else
        log_message "❌ Health check failed - HTTP $response_code"
        return 1
    fi
}

# Check system resources
check_system_resources() {
    local cpu_usage=$(top -bn1 | grep "Cpu(s)" | awk '{print $2}' | awk -F'%' '{print $1}')
    local memory_usage=$(free | grep Mem | awk '{printf("%.1f", $3/$2 * 100.0)}')
    local disk_usage=$(df -h / | awk 'NR==2{printf "%s", $5}' | sed 's/%//')
    
    log_message "📊 System stats - CPU: ${cpu_usage}%, Memory: ${memory_usage}%, Disk: ${disk_usage}%"
    
    # Alert thresholds
    if (( $(echo "$cpu_usage > 80" | bc -l) )); then
        send_alert "High CPU usage: ${cpu_usage}%"
    fi
    
    if (( $(echo "$memory_usage > 85" | bc -l) )); then
        send_alert "High memory usage: ${memory_usage}%"
    fi
    
    if [ "$disk_usage" -gt 90 ]; then
        send_alert "High disk usage: ${disk_usage}%"
    fi
}

# Check service status
check_service_status() {
    local service_status=$(systemctl is-active ${config.projectName} 2>/dev/null)
    
    if [ "$service_status" = "active" ]; then
        log_message "✅ Service ${config.projectName} is active"
        return 0
    else
        log_message "❌ Service ${config.projectName} is not active: $service_status"
        send_alert "Service ${config.projectName} is not running"
        return 1
    fi
}

# Main health check
main() {
    log_message "🔍 Starting health check for ${config.projectName}"
    
    local health_status=0
    
    # Check service status
    if ! check_service_status; then
        health_status=1
    fi
    
    # Check application health endpoint
    if ! check_app_health; then
        health_status=1
    fi
    
    # Check system resources
    check_system_resources
    
    if [ $health_status -eq 0 ]; then
        log_message "✅ Overall health check passed"
    else
        log_message "❌ Overall health check failed"
        send_alert "Health check failed for ${config.projectName}"
    fi
    
    return $health_status
}

# Run the health check
main "$@"
`;
  }

  async setupHealthCheckCron(host, config, sshOptions = {}) {
    logger.info(chalk.blue('⏰ Setting up health check cron job...'));

    const cronInterval = config.health?.interval || '*/5'; // Every 5 minutes by default
    const operatingSystem = sshOptions.operatingSystem || 'ubuntu';
    const defaultUser = operatingSystem === 'debian' ? 'admin' : 'ubuntu';
    const scriptPath = `/home/${defaultUser}/${config.projectName}/health-check.sh`;
    
    const cronJob = `${cronInterval} * * * * ${scriptPath} >/dev/null 2>&1`;
    
    try {
      // Add cron job
      await this.sshService.executeCommand(
        host,
        `(crontab -l 2>/dev/null; echo "${cronJob}") | crontab -`,
        sshOptions
      );
      
      logger.success(chalk.green(`✅ Health check cron job scheduled (every ${cronInterval} minutes)`));
    } catch (error) {
      logger.error(chalk.red(`❌ Failed to setup cron job: ${error.message}`));
      throw error;
    }
  }

  async getHealthStatus(host, config, options = {}) {
    const { dryRun = false, sshOptions = {} } = options;
    
    if (dryRun) {
      return {
        success: true,
        healthy: true,
        lastCheck: new Date().toISOString(),
        systemStats: {
          cpu: '25.5%',
          memory: '45.2%',
          disk: '35%'
        }
      };
    }

    try {
      // Run health check script
      const operatingSystem = sshOptions.operatingSystem || 'ubuntu';
      const defaultUser = operatingSystem === 'debian' ? 'admin' : 'ubuntu';
      const scriptPath = `/home/${defaultUser}/${config.projectName}/health-check.sh`;
      const healthResult = await this.sshService.executeCommand(host, scriptPath, sshOptions);
      
      // Get recent health check logs
      const logPath = `/var/log/${config.projectName}/health-check.log`;
      const logsResult = await this.sshService.executeCommand(
        host,
        `tail -n 20 ${logPath} 2>/dev/null || echo "No logs found"`,
        sshOptions
      );

      // Parse system stats from logs
      const systemStats = this.parseSystemStats(logsResult.stdout);

      return {
        success: healthResult.code === 0,
        healthy: healthResult.code === 0,
        lastCheck: new Date().toISOString(),
        logs: logsResult.stdout,
        systemStats
      };

    } catch (error) {
      return {
        success: false,
        healthy: false,
        error: error.message,
        lastCheck: new Date().toISOString()
      };
    }
  }

  parseSystemStats(logs) {
    const lines = logs.split('\n');
    const statsLine = lines.reverse().find(line => line.includes('System stats'));
    
    if (!statsLine) {
      return { cpu: 'N/A', memory: 'N/A', disk: 'N/A' };
    }

    const cpuMatch = statsLine.match(/CPU: ([\d.]+)%/);
    const memoryMatch = statsLine.match(/Memory: ([\d.]+)%/);
    const diskMatch = statsLine.match(/Disk: (\d+)%/);

    return {
      cpu: cpuMatch ? `${cpuMatch[1]}%` : 'N/A',
      memory: memoryMatch ? `${memoryMatch[1]}%` : 'N/A',
      disk: diskMatch ? `${diskMatch[1]}%` : 'N/A'
    };
  }

  async setupLogRotation(host, config, options = {}) {
    const { dryRun = false, sshOptions = {} } = options;
    
    if (dryRun) {
      logger.info(chalk.cyan(`[DRY RUN] Would setup log rotation for ${config.projectName}`));
      return { success: true };
    }

    logger.info(chalk.blue('📋 Setting up log rotation...'));

    const logrotateConfig = `
/var/log/${config.projectName}/*.log {
    daily
    missingok
    rotate 30
    compress
    delaycompress
    notifempty
    create 644 ubuntu ubuntu
    postrotate
        systemctl reload rsyslog > /dev/null 2>&1 || true
    endscript
}
`;

    try {
      const configPath = `/etc/logrotate.d/${config.projectName}`;
      await this.sshService.executeCommand(
        host,
        `sudo tee ${configPath} > /dev/null << 'EOF'\n${logrotateConfig}\nEOF`,
        sshOptions
      );

      logger.success(chalk.green('✅ Log rotation configured'));
      return { success: true };

    } catch (error) {
      logger.error(chalk.red(`❌ Failed to setup log rotation: ${error.message}`));
      throw error;
    }
  }

  async getApplicationLogs(host, config, options = {}) {
    const { lines = 50, dryRun = false, sshOptions = {} } = options;
    
    if (dryRun) {
      return {
        success: true,
        logs: `[DRY RUN] Would fetch last ${lines} lines of application logs`
      };
    }

    try {
      // Get systemd service logs
      const logsResult = await this.sshService.executeCommand(
        host,
        `sudo journalctl -u ${config.projectName} --no-pager -n ${lines}`,
        sshOptions
      );

      return {
        success: true,
        logs: logsResult.stdout
      };

    } catch (error) {
      return {
        success: false,
        error: error.message
      };
    }
  }

  async setupBasicAlerting(host, config, options = {}) {
    const { dryRun = false, sshOptions = {} } = options;
    
    if (dryRun) {
      logger.info(chalk.cyan(`[DRY RUN] Would setup basic alerting for ${config.projectName}`));
      return { success: true };
    }

    logger.info(chalk.blue('🚨 Setting up basic alerting...'));

    // Create alert configuration file
    const alertConfig = {
      enabled: true,
      thresholds: {
        cpu: config.alerts?.cpu || 80,
        memory: config.alerts?.memory || 85,
        disk: config.alerts?.disk || 90
      },
      notifications: {
        email: config.alerts?.email || null,
        webhook: config.alerts?.webhook || null
      }
    };

    try {
      const operatingSystem = sshOptions.operatingSystem || 'ubuntu';
      const defaultUser = operatingSystem === 'debian' ? 'admin' : 'ubuntu';
      const configPath = `/home/${defaultUser}/${config.projectName}/alert-config.json`;
      await this.sshService.writeFile(
        host,
        configPath,
        JSON.stringify(alertConfig, null, 2),
        sshOptions
      );

      logger.success(chalk.green('✅ Basic alerting configured'));
      logger.info(chalk.yellow('💡 Configure email or webhook in focal-deploy.yml for notifications'));

      return { success: true };

    } catch (error) {
      logger.error(chalk.red(`❌ Failed to setup alerting: ${error.message}`));
      throw error;
    }
  }
}

module.exports = { MonitoringService };